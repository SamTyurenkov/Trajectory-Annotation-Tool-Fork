<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Trajectory Annotation Tool (Frontend Only)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body {
      font-family: 'Segoe UI', Arial, sans-serif;
      background: #f6f8fa;
      margin: 0;
      padding: 0;
      min-height: 100vh;
      color: #222;
    }
    .container {
      max-width: 1100px;
      margin: 40px auto;
      background: #fff;
      border-radius: 16px;
      box-shadow: 0 4px 24px rgba(0,0,0,0.08);
      padding: 32px 32px 24px 32px;
      display: flex;
      gap: 32px;
      flex-wrap: wrap;
    }
    .left-panel {
      flex: 1 1 520px;
      min-width: 340px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .right-panel {
      flex: 1 1 340px;
      min-width: 320px;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    #canvas {
      border: 2px solid #e0e0e0;
      border-radius: 8px;
      background: #fafbfc;
      margin-top: 16px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.04);
      max-width: 100%;
      height: auto;
      transition: box-shadow 0.2s;
    }
    .controls {
      display: flex;
      gap: 12px;
      margin-bottom: 8px;
      flex-wrap: wrap;
      justify-content: center;
    }
    .controls input[type="file"] {
      display: none;
    }
    .custom-file-label {
      padding: 8px 18px;
      background: #2563eb;
      color: #fff;
      border-radius: 6px;
      cursor: pointer;
      font-weight: 500;
      transition: background 0.2s;
      border: none;
    }
    .custom-file-label:hover {
      background: #1741a6;
    }
    .btn {
      padding: 8px 18px;
      background: #f3f4f6;
      color: #222;
      border: 1px solid #e0e0e0;
      border-radius: 6px;
      cursor: pointer;
      font-weight: 500;
      transition: background 0.2s, color 0.2s;
    }
    .btn.primary {
      background: #2563eb;
      color: #fff;
      border: none;
    }
    .btn.primary:hover {
      background: #1741a6;
    }
    .btn:hover {
      background: #e5e7eb;
    }
    .json-panel {
      background: #f9fafb;
      border: 1px solid #e5e7eb;
      border-radius: 8px;
      padding: 16px;
      min-height: 220px;
      font-family: 'Fira Mono', 'Consolas', monospace;
      font-size: 15px;
      color: #2d3748;
      white-space: pre-wrap;
      word-break: break-all;
      overflow-x: auto;
      box-sizing: border-box;
      margin-bottom: 8px;
      max-height: 400px;
      overflow-y: auto;
    }
    .json-header {
      font-size: 1.1em;
      font-weight: 600;
      margin-bottom: 6px;
      color: #2563eb;
      letter-spacing: 0.5px;
    }
    .copy-btn {
      background: #e0e7ff;
      color: #2563eb;
      border: none;
      border-radius: 5px;
      padding: 4px 12px;
      font-size: 0.95em;
      cursor: pointer;
      margin-bottom: 8px;
      float: right;
      transition: background 0.2s, color 0.2s;
    }
    .copy-btn:hover {
      background: #2563eb;
      color: #fff;
    }
    @media (max-width: 900px) {
      .container { flex-direction: column; gap: 20px; padding: 18px; }
      .left-panel, .right-panel { min-width: 0; }
    }
  </style>
</head>
<body>
  <div class="container">
    <div style="width:100%;display:flex;align-items:center;gap:18px;margin-bottom:18px;flex-wrap:wrap;justify-content:center;">
      <label style="font-weight:500;">Canvas Size:</label>
      <input type="number" id="inputWidth" value="512" min="1" style="width:70px;padding:4px 8px;border-radius:5px;border:1px solid #ccc;"> x
      <input type="number" id="inputHeight" value="512" min="1" style="width:70px;padding:4px 8px;border-radius:5px;border:1px solid #ccc;">
      <span style="color:#888;font-size:0.97em;">(Set before or after uploading image)</span>
    </div>
    <div class="left-panel">
      <div class="controls">
        <label class="custom-file-label" for="imgInput">Upload Image</label>
        <input type="file" id="imgInput" accept="image/*">
        <button class="btn" id="newTrackBtn">New Track</button>
        <button class="btn" id="undoBtn">Undo</button>
        <button class="btn" id="clearBtn">Clear</button>
        <button class="btn primary" id="exportBtn">Export JSON</button>
      </div>
      <canvas id="canvas" width="800" height="600"></canvas>
      <div style="margin-top:10px;color:#888;font-size:0.98em;">Tip: Click "New Track" to start a new trajectory. Exported JSON includes all tracks.</div>
    </div>
    <div class="right-panel">
      <div class="json-header">Trajectory JSON</div>
      <button class="copy-btn" id="copyJsonBtn">Copy JSON</button>
      <div class="json-panel" id="jsonPanel">{}</div>
    </div>
  </div>
  <script>
    const imgInput = document.getElementById('imgInput');
    const inputWidth = document.getElementById('inputWidth');
    const inputHeight = document.getElementById('inputHeight');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const exportBtn = document.getElementById('exportBtn');
    const newTrackBtn = document.getElementById('newTrackBtn');
    const undoBtn = document.getElementById('undoBtn');
    const clearBtn = document.getElementById('clearBtn');
    const jsonPanel = document.getElementById('jsonPanel');
    const copyJsonBtn = document.getElementById('copyJsonBtn');
    const fileLabel = document.querySelector('.custom-file-label');

    let img = null;
    let drawing = false;
    let currentTrack = [];
    let allTracks = [];
    let colors = ['#2563eb', '#059669', '#f59e42', '#e11d48', '#a21caf', '#0ea5e9', '#fbbf24', '#10b981', '#f43f5e'];
    // Track hues for color gradients
    const trackHues = [210, 140, 30, 270, 0, 320, 180, 50, 90];
    // History of all drawing actions (each is a track segment drawn in one mouse drag)
    let drawHistory = [];

    // Update JSON panel (export only tracks array)
    function updateJsonPanel() {
      let tracks = allTracks.slice();
      if (currentTrack.length > 0) tracks.push(currentTrack);
      jsonPanel.textContent = JSON.stringify(tracks, null, 2);
    }

    // File input
    imgInput.addEventListener('change', e => {
      const file = e.target.files[0];
      if (!file) return;
      loadImageFile(file);
    });

    // New track
    newTrackBtn.addEventListener('click', () => {
      // New Track button: just ends current drawing, but in new undo模式已不需要特殊处理
      // 保持兼容性，清空 currentTrack
      currentTrack = [];
      redraw();
      updateJsonPanel();
    });

    // Undo the last point of the current track
    // Undo button: remove the last drawing segment (mouse drag)
    undoBtn.addEventListener('click', () => {
      if (drawHistory.length > 0) {
        drawHistory.pop();
        updateTracksFromHistory();
        redraw();
        updateJsonPanel();
      }
    });

    // Clear all tracks and current drawing
    clearBtn.addEventListener('click', () => {
      allTracks = [];
      currentTrack = [];
      drawHistory = [];
      redraw();
      updateJsonPanel();
    });

    // Draw track
    // --- Drawing logic: record each mouse drag as a segment in drawHistory ---
    let tempTrack = [];
    canvas.addEventListener('mousedown', e => {
      if (!img) return;
      drawing = true;
      tempTrack = [];
      const [x, y] = getXY(e);
      tempTrack.push({x, y});
      redrawWithTemp(tempTrack);
    });

    canvas.addEventListener('mousemove', e => {
      if (!drawing || !img) return;
      const [x, y] = getXY(e);
      tempTrack.push({x, y});
      redrawWithTemp(tempTrack);
    });

    canvas.addEventListener('mouseup', e => {
      if (drawing && tempTrack.length > 0) {
        drawHistory.push(tempTrack.slice()); // Save this segment
        updateTracksFromHistory();
        redraw();
        updateJsonPanel();
      }
      drawing = false;
      tempTrack = [];
    });
    canvas.addEventListener('mouseleave', e => {
      if (drawing && tempTrack.length > 0) {
        drawHistory.push(tempTrack.slice());
        updateTracksFromHistory();
        redraw();
        updateJsonPanel();
      }
      drawing = false;
      tempTrack = [];
    });

    // Redraw with a temporary track (for live drawing preview)
    function redrawWithTemp(temp) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (img) ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
      drawHistory.forEach((track, idx) => {
        drawTrack(track, colors[idx % colors.length], idx);
      });
      if (temp && temp.length > 0) {
        drawTrack(temp, colors[drawHistory.length % colors.length], drawHistory.length);
      }
    }

    // Update allTracks/currentTrack from drawHistory
    function updateTracksFromHistory() {
      // allTracks: all finished tracks, currentTrack: empty
      allTracks = drawHistory.map(seg => seg.slice());
      currentTrack = [];
    }

    // --- Image resizing and canvas size logic ---
    // Resize and draw image to fit target size, using bilinear interpolation, center align
    function drawResizedImageToCanvas(image, targetW, targetH) {
      // Create a temp canvas for resizing
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = targetW;
      tempCanvas.height = targetH;
      const tctx = tempCanvas.getContext('2d');
      // Fill with white background
      tctx.fillStyle = '#fff';
      tctx.fillRect(0, 0, targetW, targetH);
      // Compute scale and offset for center align
      const scale = Math.min(targetW / image.width, targetH / image.height);
      const drawW = image.width * scale;
      const drawH = image.height * scale;
      const dx = (targetW - drawW) / 2;
      const dy = (targetH - drawH) / 2;
      // Use bilinear interpolation
      tctx.imageSmoothingEnabled = true;
      tctx.imageSmoothingQuality = 'high';
      tctx.drawImage(image, 0, 0, image.width, image.height, dx, dy, drawW, drawH);
      // Draw to main canvas
      ctx.clearRect(0, 0, targetW, targetH);
      ctx.drawImage(tempCanvas, 0, 0);
    }

    // When user changes width/height, resize canvas and redraw image/track
    function updateCanvasSizeAndRedraw() {
      const w = parseInt(inputWidth.value) || 512;
      const h = parseInt(inputHeight.value) || 512;
      canvas.width = w;
      canvas.height = h;
      redraw();
      updateJsonPanel();
    }

    inputWidth.addEventListener('change', updateCanvasSizeAndRedraw);
    inputHeight.addEventListener('change', updateCanvasSizeAndRedraw);
    // --- End Image resizing and canvas size logic ---

    // Export JSON
    exportBtn.addEventListener('click', () => {
      let tracks = allTracks.slice();
      if (currentTrack.length > 0) tracks.push(currentTrack);
      // Only export tracks array
      const blob = new Blob([JSON.stringify(tracks, null, 2)], {type: 'application/json'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'tracks.json';
      a.click();
      URL.revokeObjectURL(url);
    });

    // Copy JSON
    copyJsonBtn.addEventListener('click', () => {
      navigator.clipboard.writeText(jsonPanel.textContent).then(() => {
        copyJsonBtn.textContent = 'Copied!';
        setTimeout(() => copyJsonBtn.textContent = 'Copy JSON', 1200);
      });
    });

    // Utility
    function getXY(e) {
      const rect = canvas.getBoundingClientRect();
      return [
        Math.round((e.clientX - rect.left) * canvas.width / rect.width),
        Math.round((e.clientY - rect.top) * canvas.height / rect.height)
      ];
    }

    function redraw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      // Draw resized image with bilinear interpolation, center align
      if (img) drawResizedImageToCanvas(img, canvas.width, canvas.height);
      // Draw all tracks from drawHistory
      drawHistory.forEach((track, idx) => {
        drawTrack(track, colors[idx % colors.length], idx);
      });
      // Draw current track (should always be empty in new undo mode, but for compatibility)
      if (currentTrack.length > 0) {
        drawTrack(currentTrack, colors[drawHistory.length % colors.length], drawHistory.length);
      }
    }

    function drawTrack(track, color, trackIdx = 0) {
      if (track.length === 0) return;
      // Use different gradients of the same color family for different tracks
      function getGradient(t) {
        // t: 0~1
        const hue = trackHues[trackIdx % trackHues.length];
        const l = 85 - 50 * t; // 85% -> 35%
        return `hsl(${hue}, 90%, ${l}%)`;
      }

      ctx.lineWidth = 7;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      for (let i = 1; i < track.length; ++i) {
        const t = i / (track.length - 1);
        ctx.strokeStyle = getGradient(t);
        ctx.beginPath();
        ctx.moveTo(track[i - 1].x, track[i - 1].y);
        ctx.lineTo(track[i].x, track[i].y);
        ctx.stroke();
      }

      // 起点大圆（绿色）
      ctx.fillStyle = '#22c55e';
      ctx.beginPath();
      ctx.arc(track[0].x, track[0].y, 11, 0, 2 * Math.PI);
      ctx.fill();
      ctx.strokeStyle = '#16a34a';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(track[0].x, track[0].y, 11, 0, 2 * Math.PI);
      ctx.stroke();

      // 终点箭头（红色）
      if (track.length > 1) {
        const end = track[track.length - 1];
        const prev = track[track.length - 2];
        const dx = end.x - prev.x;
        const dy = end.y - prev.y;
        const len = Math.sqrt(dx * dx + dy * dy) || 1;
        const ux = dx / len, uy = dy / len;
        // 箭头主线
        ctx.strokeStyle = '#ef4444';
        ctx.lineWidth = 5;
        ctx.beginPath();
        ctx.moveTo(prev.x, prev.y);
        ctx.lineTo(end.x, end.y);
        ctx.stroke();
        // 箭头两翼
        const arrowLen = 22, angle = Math.PI / 7;
        for (let sign of [-1, 1]) {
          const theta = Math.atan2(uy, ux) + sign * angle;
          const x2 = end.x - arrowLen * Math.cos(theta);
          const y2 = end.y - arrowLen * Math.sin(theta);
          ctx.beginPath();
          ctx.moveTo(end.x, end.y);
          ctx.lineTo(x2, y2);
          ctx.stroke();
        }
        // 终点圆
        ctx.fillStyle = '#ef4444';
        ctx.beginPath();
        ctx.arc(end.x, end.y, 8, 0, 2 * Math.PI);
        ctx.fill();
      }
    }

    // 鼠标悬停显示坐标
    let hoverPoint = null;
    canvas.addEventListener('mousemove', e => {
      if (drawing || !img) return;
      const [mx, my] = getXY(e);
      let found = null;
      // 检查所有轨迹点
      for (const track of [...allTracks, currentTrack]) {
        for (const pt of track) {
          if (Math.abs(pt.x - mx) < 10 && Math.abs(pt.y - my) < 10) {
            found = pt;
            break;
          }
        }
        if (found) break;
      }
      hoverPoint = found;
      redraw();
      if (hoverPoint) {
        // 显示坐标提示
        ctx.save();
        ctx.font = 'bold 15px Segoe UI, Arial';
        ctx.fillStyle = '#fff';
        ctx.strokeStyle = '#2563eb';
        ctx.lineWidth = 4;
        const text = `(${hoverPoint.x}, ${hoverPoint.y})`;
        const tx = hoverPoint.x + 14, ty = hoverPoint.y - 10;
        ctx.strokeText(text, tx, ty);
        ctx.fillStyle = '#2563eb';
        ctx.fillText(text, tx, ty);
        ctx.restore();
      }
    });
    canvas.addEventListener('mouseleave', e => {
      if (!drawing) {
        hoverPoint = null;
        redraw();
      }
    });

    // --- Drag & Drop and Paste Image Support ---
    // Handle drag over canvas (show visual feedback)
    canvas.addEventListener('dragover', function(e) {
      e.preventDefault();
      canvas.style.boxShadow = '0 0 0 4px #2563eb55';
    });
    canvas.addEventListener('dragleave', function(e) {
      e.preventDefault();
      canvas.style.boxShadow = '';
    });
    // Handle drop image file on canvas
    canvas.addEventListener('drop', function(e) {
      e.preventDefault();
      canvas.style.boxShadow = '';
      if (e.dataTransfer.files && e.dataTransfer.files[0]) {
        const file = e.dataTransfer.files[0];
        if (file.type.startsWith('image/')) {
          loadImageFile(file);
        }
      }
    });

    // Handle paste image from clipboard
    window.addEventListener('paste', function(e) {
      if (e.clipboardData && e.clipboardData.items) {
        for (let i = 0; i < e.clipboardData.items.length; i++) {
          const item = e.clipboardData.items[i];
          if (item.type.startsWith('image/')) {
            const file = item.getAsFile();
            if (file) {
              loadImageFile(file);
              break;
            }
          }
        }
      }
    });

    // Helper to load image file (from input, drop, or paste)
    function loadImageFile(file) {
      fileLabel.textContent = file.name || 'Image';
      const reader = new FileReader();
      reader.onload = function(evt) {
        img = new window.Image();
        img.onload = function() {
          // Set canvas to target size
          const w = parseInt(inputWidth.value) || 512;
          const h = parseInt(inputHeight.value) || 512;
          canvas.width = w;
          canvas.height = h;
          redraw();
          updateJsonPanel();
        };
        img.src = evt.target.result;
      };
      reader.readAsDataURL(file);
      // Clear tracks
      allTracks = [];
      currentTrack = [];
      drawHistory = [];
      updateJsonPanel();
    }

    // --- End Drag & Drop and Paste Support ---

    // Initial JSON panel
    updateJsonPanel();
  </script>
</body>
</html> 